{
    "id": "695966",
    "timePublished": "2022-10-28T13:17:45+00:00",
    "isCorporative": false,
    "lang": "ru",
    "titleHtml": "Создаём асинхронный Fluent API",
    "leadData": {
        "textHtml": "<p>Недавно я захотел сделать более удобный способ взаимодействия с кое-каким классом в одном из модулей приложения. Тогда-то я вспомнил про Fluent API, который в моём случае очень хорошо подходил.</p><p>Я нашёл кучу объяснений и примеров кода для реализации Fluent API, однако я не мог найти внятных объяснений, как реализовать в этом же Fluent API асинхронные методы, аки делает это какой-нибудь Linq. Библиотеки используют какую-то эльфийскую магию, но я нашёл драйвер MongoDB, на исходном коде которого я и разбирался, как реализовать асинхронный Fluent API.</p><p>Для тех, кто не знаком с темой Fluent API, прошу к прочтению.</p>",
        "imageUrl": "https://habrastorage.org/getpro/habr/upload_files/ff3/a13/d50/ff3a13d504fcb09947e7a0b9508a7227.jpg",
        "buttonTextHtml": "Читать далее",
        "image": {
            "url": "https://habrastorage.org/getpro/habr/upload_files/ff3/a13/d50/ff3a13d504fcb09947e7a0b9508a7227.jpg",
            "fit": "cover",
            "positionY": 0,
            "positionX": 0
        }
    },
    "editorVersion": "2.0",
    "postType": "article",
    "postLabels": [],
    "author": {
        "id": "2829449",
        "alias": "Ertanic",
        "fullname": null,
        "avatarUrl": null,
        "speciality": null,
        "scoreStats": {
            "score": 2,
            "votesCount": 4
        },
        "rating": 0,
        "relatedData": null,
        "contacts": [],
        "authorContacts": [],
        "paymentDetails": {
            "paymentYandexMoney": null,
            "paymentPayPalMe": null,
            "paymentWebmoney": null
        }
    },
    "statistics": {
        "commentsCount": 0,
        "favoritesCount": 8,
        "readingCount": 915,
        "score": 0,
        "votesCount": 2,
        "votesCountPlus": 1,
        "votesCountMinus": 1
    },
    "hubs": [
        {
            "id": "17690",
            "alias": "api",
            "type": "collective",
            "title": "API",
            "titleHtml": "API",
            "isProfiled": true,
            "relatedData": null
        },
        {
            "id": "17718",
            "alias": "csharp",
            "type": "collective",
            "title": "C#",
            "titleHtml": "C#",
            "isProfiled": true,
            "relatedData": null
        },
        {
            "id": "17719",
            "alias": "oop",
            "type": "collective",
            "title": "ООП",
            "titleHtml": "ООП",
            "isProfiled": true,
            "relatedData": null
        },
        {
            "id": "17822",
            "alias": "parallel_programming",
            "type": "collective",
            "title": "Параллельное программирование",
            "titleHtml": "Параллельное программирование",
            "isProfiled": true,
            "relatedData": null
        }
    ],
    "flows": [
        {
            "id": "1",
            "alias": "develop",
            "title": "Разработка",
            "titleHtml": "Разработка"
        }
    ],
    "relatedData": null,
    "textHtml": "<div xmlns=\"http://www.w3.org/1999/xhtml\"><p>Недавно я захотел сделать более удобный способ взаимодействия с кое-каким классом в одном из модулей приложения. Тогда-то я вспомнил про Fluent API, который в моём случае очень хорошо подходил.</p><p>Я нашёл кучу объяснений и примеров кода для реализации Fluent API, однако я не мог найти внятных объяснений, как реализовать в этом же Fluent API асинхронные методы, аки делает это какой-нибудь Linq. Библиотеки используют какую-то эльфийскую магию, но я нашёл драйвер MongoDB, на исходном коде которого я и разбирался, как реализовать асинхронный Fluent API.</p><h2>Содержание</h2><ol><li><p><a href=\"#%D0%A7%D1%82%D0%BE_%D1%82%D0%B0%D0%BA%D0%BE%D0%B5_FluentAPI\" rel=\"noopener noreferrer nofollow\">Что такое Fluent API</a>;</p></li><li><p><a href=\"#%D0%A0%D0%B5%D0%B0%D0%BB%D0%B8%D0%B7%D1%83%D0%B5%D0%BC_%D0%B0%D1%81%D0%B8%D0%BD%D1%85%D1%80%D0%BE%D0%BD%D0%BD%D1%8B%D0%B9_FluentAPI\" rel=\"noopener noreferrer nofollow\">Реализуем асинхронный Fluent API</a>:</p><ol><li><p><a href=\"#%D0%93%D0%BE%D1%82%D0%BE%D0%B2%D0%B8%D0%BC%D1%81%D1%8F_%D1%82%D0%B2%D0%BE%D1%80%D0%B8%D1%82%D1%8C\" rel=\"noopener noreferrer nofollow\">Готовимся творить</a>;</p></li><li><p><a href=\"#%D0%94%D0%B5%D0%BB%D0%B0%D0%B5%D0%BC_%D1%81%D0%BA%D0%B5%D0%BB%D0%B5%D1%82_%D0%BF%D1%80%D0%B8%D0%BB%D0%BE%D0%B6%D0%B5%D0%BD%D0%B8%D1%8F\" rel=\"noopener noreferrer nofollow\">Делаем скелет приложения</a>:</p><ol><li><p><a href=\"#%D0%9F%D0%B5%D1%80%D0%B2%D1%8B%D0%B9_%D1%81%D0%BB%D1%83%D1%87%D0%B0%D0%B9\" rel=\"noopener noreferrer nofollow\">Первый случай реализации Fluent API</a>;</p></li><li><p><a href=\"#%D0%92%D1%82%D0%BE%D1%80%D0%BE%D0%B9_%D1%81%D0%BB%D1%83%D1%87%D0%B0%D0%B9\" rel=\"noopener noreferrer nofollow\">Второй случай реализации Fluent API</a>;</p></li></ol></li><li><p><a href=\"#%D0%94%D0%BE%D0%B1%D0%B0%D0%B2%D0%BB%D1%8F%D0%B5%D0%BC_%D0%B0%D1%81%D0%B8%D0%BD%D1%85%D1%80%D0%BE%D0%BD%D0%BD%D0%BE%D1%81%D1%82%D1%8C\" rel=\"noopener noreferrer nofollow\">Добавляем асинхронность</a>;</p></li></ol></li><li><p><a href=\"#Optional_pattern\" rel=\"noopener noreferrer nofollow\">Optional pattern</a>;</p></li><li><p><a href=\"#%D0%98%D1%82%D0%BE%D0%B3%D0%BE\" rel=\"noopener noreferrer nofollow\">Итого</a>.</p></li></ol><a class=\"anchor\" name=\"%D0%A7%D1%82%D0%BE_%D1%82%D0%B0%D0%BA%D0%BE%D0%B5_FluentAPI\" id=\"Что_такое_FluentAPI\"></a><h2>Что такое Fluent API</h2><p>Не буду пытаться сформулировать определение Fluent API, поэтому давайте обратимся к старой-доброй <a href=\"https://en.wikipedia.org/wiki/Fluent_interface\" rel=\"noopener noreferrer nofollow\">Википедии</a>:</p><blockquote><p>    В программной инженерии <strong>Fluent API</strong> —<strong> </strong>это объектно-ориентированный API, дизайн которого в значительной степени зависит от цепочки методов. Его цель - повысить разборчивость кода путем создания DSL. Термин был введен в 2005 году Эриком Эвансом и Мартином Фаулером.</p></blockquote><p>Из непонятных слов в этом определении является лишь DSL. <strong>DSL</strong> - это, если по-житейски, язык программирования, созданный для выполнения какой-то конкретной задачи в определённой предметной области. Для примера, наверное, можно привести такие языки, как <a href=\"https://learn.microsoft.com/en-us/dotnet/csharp/programming-guide/concepts/linq/\" rel=\"noopener noreferrer nofollow\"><em>LINQ</em></a><em>, </em><a href=\"https://practicum.yandex.ru/blog/chto-takoe-sql/\" rel=\"noopener noreferrer nofollow\"><em>SQL</em></a><em>, </em><a href=\"https://graphql.org/\" rel=\"noopener noreferrer nofollow\"><em>GraphQL</em></a><em>, </em><a href=\"https://metanit.com/sharp/tutorial/7.4.php\" rel=\"noopener noreferrer nofollow\"><em>Regex</em></a><em>, </em><a href=\"https://habr.com/ru/company/yandex/blog/484068/\" rel=\"noopener noreferrer nofollow\"><em>gRPC</em></a><em>, </em><a href=\"https://lifehacker.ru/chto-takoe-markdown/\" rel=\"noopener noreferrer nofollow\"><em>Markdown</em></a><em> и т.п</em>, которые предназначены для действий с источниками данных, поиска совпадений в тексте по паттернам, описания сетевых интерфейсов, а также форматирования контента, соответственно. Кстати, известные фреймворки по типу <a href=\"https://habr.com/ru/post/319270/\" rel=\"noopener noreferrer nofollow\"><em>React</em></a> и <a href=\"https://specialties.bayt.com/en/specialties/q/1906/is-jquery-a-dsl/\" rel=\"noopener noreferrer nofollow\"><em>JQuery </em></a>также являются внешними DSL и называются <strong>eDSL</strong>. Исходя из второй ссылки на форум про JQuery можно сделать вывод, что данные фреймворки являются DSL из-за того, что являются более удобной прослойкой, которая потом будет преобразована в стандартный Javascript-код. Ну, или что-то такое. Более подробно про DSL прошу в эту <a href=\"https://habr.com/ru/post/94259/\" rel=\"noopener noreferrer nofollow\">статью</a>, в которой рассказывается про, собственно, DSL, что такое API и др.</p><p>В этой <a href=\"https://dev.to/mcc_ahmed/building-your-first-async-fluent-api-using-interface-extension-methods-pattern-266a\" rel=\"noopener noreferrer nofollow\">статье</a> (статья, кстати, тоже про асинхронный Fluent API, однако там нисколько ничего не понятно) нашёл пример кода в Fluent-стиле и его аналоге в императивном стиле, соответственно, чтобы понять, в чём прелесть Fluent API:</p><pre><code class=\"cs\">var data = await GetNewsAsync()\n         .Where(newsList => newsList.Date >= DateTime.Today)\n         .SelectMany(newsList => newsList.NewsItems)\n         .ToList();</code></pre><pre><code class=\"cs\">var newsList = await GetNewsAsync();\n\nif (newsList.Date >= DateTime.Today)\n{\n   return newsList.Select(news=>news.NewsItems).ToList();\n}\n\nreturn new List&lt;NewsItem>();</code></pre><p>Как мы можем наблюдать из примеров выше, Fluent API делает код более компактным и, соответственно, более читаемым, что есть однозначно хорошо.</p><a class=\"anchor\" name=\"%D0%A0%D0%B5%D0%B0%D0%BB%D0%B8%D0%B7%D1%83%D0%B5%D0%BC_%D0%B0%D1%81%D0%B8%D0%BD%D1%85%D1%80%D0%BE%D0%BD%D0%BD%D1%8B%D0%B9_FluentAPI\" id=\"Реализуем_асинхронный_FluentAPI\"></a><h2>Реализуем асинхронный Fluent API</h2><p>Для начала, думаю, стоит начать с простого и идти дальше, поэтому для начала сделаем конструктор SQL-соединения, который также позволит асинхронно получать данные из БД (которой будет являться простой список).</p><p>Кстати, для тех, кто мало знаком с асинхронным программированием, рекомендую к прочтению вот эту прекрасную <a href=\"https://habr.com/ru/post/470830/#conception\" rel=\"noopener noreferrer nofollow\">статью</a>.</p><a class=\"anchor\" name=\"%D0%93%D0%BE%D1%82%D0%BE%D0%B2%D0%B8%D0%BC%D1%81%D1%8F_%D1%82%D0%B2%D0%BE%D1%80%D0%B8%D1%82%D1%8C\" id=\"Готовимся_творить\"></a><h3>Готовимся творить</h3><p>Давайте создадим решение и проект где-то на компьютере и откроем созданное решение в всеми любимом <a href=\"https://visualstudio.microsoft.com/ru/\" rel=\"noopener noreferrer nofollow\">Visual Studio Code</a> с установленным официальным <a href=\"https://marketplace.visualstudio.com/items?itemName=ms-dotnettools.csharp\" rel=\"noopener noreferrer nofollow\">плагином для C#</a> и <a href=\"https://marketplace.visualstudio.com/items?itemName=GitHub.copilot\" rel=\"noopener noreferrer nofollow\">Github Copilot</a> (мой рекомедосьён), используя следующие команды, если кому интересно:</p><pre><code class=\"bash\">$ dotnet new sln\n$ dotnet new console -o ./src/FluentAPI\n$ dotnet sln add ./src/FluentAPI\n$ code .</code></pre><p>Теперь перейдём к написанию кода...</p><figure class=\"full-width \"><img src=\"https://habrastorage.org/r/w780q1/getpro/habr/upload_files/9fb/71a/3d5/9fb71a3d5c731967607287f642ab89ca.jpg\" alt=\"Енотик, готовый кодить\" title=\"Енотик, готовый кодить\" width=\"900\" height=\"602\" data-src=\"https://habrastorage.org/getpro/habr/upload_files/9fb/71a/3d5/9fb71a3d5c731967607287f642ab89ca.jpg\" data-blurred=\"true\"/><figcaption>Енотик, готовый кодить</figcaption></figure><a class=\"anchor\" name=\"%D0%94%D0%B5%D0%BB%D0%B0%D0%B5%D0%BC_%D1%81%D0%BA%D0%B5%D0%BB%D0%B5%D1%82_%D0%BF%D1%80%D0%B8%D0%BB%D0%BE%D0%B6%D0%B5%D0%BD%D0%B8%D1%8F\" id=\"Делаем_скелет_приложения\"></a><h3>Делаем скелет приложения</h3><p>Наше приложение будет получать из «базы данных» данные (как я люблю тавтологию), которые будут какими-то числами, затем выводить эти числа в терминал.</p><p>С приложением определились, теперь идём в файл <code>Program.cs</code>, находящийся в созданном по пути <code>./src/FluentAPI</code> проекте, где меняем содержимое файла на следующее:</p><pre><code class=\"cs\">namespace FluentAPI;\n\npublic class Program {\n    public static void Main(string[] args) {\n        var numbers = FluentSQLConnection&lt;int>\n            //  С помощью статического метода CreateConnection создаём и \n            //  настраиваем экземляр класса FluentSQLConnection\n            .CreateConnection(builder => {\n                builder.ConnectionString = \"Data Source=.;Initial Catalog=FluentAPI;Integrated Security=True\";\n                builder.Data = Enumerable.Range(0, 100).ToList();\n            })\n            .Query(\"SELECT * FROM Numbers\") //  Выполняем запрос к базе данных\n            .Where(n => n % 2 == 0) //  Выбираем только чётные числа\n            .ToList(); //  Получаем результат запроса в виде списка\n\n        //  Выводим результат запроса в консоль\n        foreach (var number in numbers) {\n            System.Console.WriteLine(number);\n        }\n    }\n}</code></pre><p>Из кода выше понятно, наверное, что код не будет выполняться асинхронно. Асинхронность введём позже. Кстати, не обращайте внимание на <code>builder.Data = Enumerable.Range(0, 100).ToList();</code>, это нужно исключительно для того, чтобы ввести тестовый источник данных, ведь реальной базы данных нету.</p><p>А сейчас давайте создадим класс <code>FluentSQLConnection</code>. Для этого создадим файл <code>FluentSQLConnection.cs</code>. Обычно Fluent API лишь меняет состояние класса, однако, в принципе, никто не запрещает вернуть методом <code>Query(string)</code> тип <code>IEnumerable&lt;TData></code>. </p><a class=\"anchor\" name=\"%D0%9F%D0%B5%D1%80%D0%B2%D1%8B%D0%B9_%D1%81%D0%BB%D1%83%D1%87%D0%B0%D0%B9\" id=\"Первый_случай\"></a><h4>Первый случай</h4><pre><code class=\"cs\">using Microsoft.Data.SqlClient;\n\nnamespace FluentAPI;\n\npublic record FluentSQLConnectionBuilder&lt;TData>\n{\n    public string ConnectionString { get; set; }\n    public List&lt;TData> Data { get; set; }\n}\n\npublic interface IFluentSQLQuery&lt;TData>\n{\n    IFluentSQLSelection&lt;TData> Query(string sql);\n}\n\npublic interface IFluentSQLQueryResult&lt;TData>\n{\n    List&lt;TData> ToList();\n}\n\npublic interface IFluentSQLSelection&lt;TData> : IFluentSQLQueryResult&lt;TData>\n{\n    IFluentSQLSelection&lt;TData> Where(Func&lt;TData, bool> predicate);\n\n}\n\npublic sealed class FluentSQLConnection&lt;TData>\n    : IFluentSQLQuery&lt;TData>, IFluentSQLQueryResult&lt;TData>, IFluentSQLSelection&lt;TData>\n{\n    IEnumerable&lt;TData> _data;\n    IEnumerable&lt;TData> _queredData;\n    SqlConnection _connection;\n\n    FluentSQLConnection(string connectionString, IEnumerable&lt;TData> data)\n    {\n        _connection = new SqlConnection(connectionString);\n        _queredData = new List&lt;TData>();\n        _data = data;\n    }\n\n    public static IFluentSQLQuery&lt;TData> CreateConnection(Action&lt;FluentSQLConnectionBuilder&lt;TData>> configureConnection)\n    {\n        var builder = new FluentSQLConnectionBuilder&lt;TData>() { \n            ConnectionString = \"\",\n            Data = new List&lt;TData>() \n        };\n        configureConnection(builder);\n        return new FluentSQLConnection&lt;TData>(builder.ConnectionString, builder.Data);\n    }\n\n\n    IFluentSQLSelection&lt;TData> IFluentSQLQuery&lt;TData>.Query(string sql)\n    {\n        // _connection.Open();\n        // var command = new SqlCommand(sql, _connection);\n        // var reader = command.ExecuteReader();\n        // var data = new List&lt;TData>();\n        // while (reader.Read())\n        // {\n        //     data.Add((TData)reader[0]);\n        // }\n        // _queredData = data;\n        // _connection.Close();\n\n        Task.Delay(1000).Wait();\n        _queredData = _data;\n\n        return this;\n    }\n\n    public IFluentSQLSelection&lt;TData> Where(Func&lt;TData, bool> predicate)\n    {\n        _queredData = _queredData.Where(predicate);\n        return this;\n    }\n\n    List&lt;TData> IFluentSQLQueryResult&lt;TData>.ToList() => _queredData.ToList();\n}</code></pre><details class=\"spoiler\"><summary>Microsoft.Data.SqlClient</summary><div class=\"spoiler__content\"><p>Для тех, кто не знает, то библиотеку <code>Microsoft.Data.SqlClient</code>, которая, по-идее, является частью <a href=\"https://learn.microsoft.com/ru-ru/dotnet/framework/data/adonet/?redirectedfrom=MSDN\" rel=\"noopener noreferrer nofollow\">ADO.NET</a>, нужно устанавливать в проект ручками. Для того, чтобы установить библиотеку, необходимо открыть терминал в VS Code и набрать следующую команду:</p><pre><code class=\"bash\">$ dotnet add ./src/FluentAPI package Microsoft.Data.SqlClient</code></pre><p>Путь после оператора <code>add</code> позволяет указать проект, в который необходимо добавить библиотеку, название которой идёт после оператора <code>package</code>, указывающий тип того, что нужно добавить в проект: другой проект или пакет NuGet.</p></div></details><p>По логике наш метод <code>Query(string)</code> может выбирать лишь раз, поэтому наш класс использует интерфейсный подход, что выражается в том, что ранее упомянутый метод возвращает тип, наследующий интерфейс <code>IFluentSQLQueryResult&lt;TData></code>, то есть наш класс <code>FluentSQLConnection&lt;TData></code>. Данный подход также используется тогда, когда в нашем конечном автомате имеется множество свойств. Где-то на этом времени в данном видео объясняется наглядно то, о чём я говорю сейчас:</p><div class=\"tm-iframe_temp\" data-src=\"https://embedd.srv.habr.com/iframe/63559bdf0c924e8d4165ee8d\" data-style=\"\" id=\"63559bdf0c924e8d4165ee8d\" width=\"\"></div><p>Классный видос, как и многие другие видео на <a href=\"https://www.youtube.com/watch?v=1JAdZul-aRQ&amp;list=RDCMUCrkPsvLGln62OMZRO6K-llg&amp;start_radio=1\" rel=\"noopener noreferrer nofollow\">канале Ника</a>. Если ничего не понятно в настоящей статье, то рекомендую посмотреть данное видео. Кстати, именно пример Ника я сейчас использую.</p><p>Как ранее упоминалось, не обращаем внимание на всё, что связано с <code>Data</code> и <code>_data</code> в классе. Кусок работы с SQL-запросами, предложенный Github Copilot в методе <code>IFluentSQLQuery.Query(string sql)</code>, решил оставить в качестве примера того, как может выглядеть реальный случай использования данного подхода. Права, кто будет делать подобный велосипед, когда есть прекрасный <a href=\"https://skillbox.ru/media/code/entity_framework/\" rel=\"noopener noreferrer nofollow\">Entity Framework</a> и менее прекрасный, но шустрый <a href=\"https://habr.com/ru/post/665836/\" rel=\"noopener noreferrer nofollow\">Dapper</a>? Но всё же.</p><a class=\"anchor\" name=\"%D0%92%D1%82%D0%BE%D1%80%D0%BE%D0%B9_%D1%81%D0%BB%D1%83%D1%87%D0%B0%D0%B9\" id=\"Второй_случай\"></a><h4>Второй случай</h4><pre><code class=\"cs\">using Microsoft.Data.SqlClient;\n\nnamespace FluentAPI;\n\npublic record FluentSQLConnectionBuilder&lt;TData>\n{\n    public string ConnectionString { get; set; }\n    public List&lt;TData> Data { get; set; }\n}\n\npublic sealed class FluentSQLConnection&lt;TData>\n{\n    IEnumerable&lt;TData> _data;\n    SqlConnection _connection;\n\n    FluentSQLConnection(string connectionString, IEnumerable&lt;TData> data)\n    {\n        _connection = new SqlConnection(connectionString);\n        _data = data;\n    }\n\n    public static FluentSQLConnection&lt;TData> CreateConnection(Action&lt;FluentSQLConnectionBuilder&lt;TData>> configureConnection)\n    {\n        var builder = new FluentSQLConnectionBuilder&lt;TData>() { \n            ConnectionString = \"\",\n            Data = new List&lt;TData>() \n        };\n        configureConnection(builder);\n        return new FluentSQLConnection&lt;TData>(builder.ConnectionString, builder.Data);\n    }\n\n\n    public IEnumerable&lt;TData> Query(string sql)\n    {\n        // _connection.Open();\n        // var command = new SqlCommand(sql, _connection);\n        // var reader = command.ExecuteReader();\n        // var data = new List&lt;TData>();\n        // while (reader.Read())\n        // {\n        //     data.Add((TData)reader[0]);\n        // }\n        // _queredData = data;\n        // _connection.Close();\n\n        Task.Delay(1000).Wait();\n        return _data;\n    }\n}</code></pre><p>Как мы можем наблюдать в коде, второй случай куда компактнее и проще в исполнении, так как уже готовые решения Linq позволяют реализовать ровно то же самое без излишнего кода: что там, что там будет вывод следующий:</p><figure class=\"full-width \"><img src=\"https://habrastorage.org/r/w1560/getpro/habr/upload_files/90c/be7/1c3/90cbe71c348cb97a57ea383c96f0e2aa.png\" alt=\"Вывод программы\" title=\"Вывод программы\" width=\"606\" height=\"586\" data-src=\"https://habrastorage.org/getpro/habr/upload_files/90c/be7/1c3/90cbe71c348cb97a57ea383c96f0e2aa.png\"/><figcaption>Вывод программы</figcaption></figure><p>Поэтому считаю, что можно обходиться вторым подходом, если контекст того позволяет. Под контекстом я подразумеваю задачу и уже готовые решения для её решения.</p><a class=\"anchor\" name=\"%D0%94%D0%BE%D0%B1%D0%B0%D0%B2%D0%BB%D1%8F%D0%B5%D0%BC_%D0%B0%D1%81%D0%B8%D0%BD%D1%85%D1%80%D0%BE%D0%BD%D0%BD%D0%BE%D1%81%D1%82%D1%8C\" id=\"Добавляем_асинхронность\"></a><h3>Добавляем асинхронность</h3><p>Судя по тем исходникам, что я мог наблюдать, а точнее ранее упомянутые исходники MongoDB, реализуется всё это через такую структуру данных, как очередь. Для тех, кто не знаком с этим типом данных, могу посоветовать просмотреть исчерпывающую <a href=\"https://ru.wikipedia.org/wiki/%D0%9E%D1%87%D0%B5%D1%80%D0%B5%D0%B4%D1%8C_(%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5)\" rel=\"noopener noreferrer nofollow\">статью на Википедии</a>.</p><p>Вообще, если говорить про MongoDB, там всё слишком запутано на мой взгляд, так как там используется куча всяких абстракций и вообще вместо очереди используется <a href=\"https://pikabu.ru/story/slovar_map_na_yazyike_c_5803175\" rel=\"noopener noreferrer nofollow\">словарь</a>. Точно не знаю, но предполагаю, что всё это используется для дальнейшего маппинга из сущностей БД в объекты C#.</p><p>Но в нашем случае всё будет куда проще, то есть реализовано через простую очередь. Чтобы это сделать, сначала скопируем файл с первым случаем реализации Fluent API и переименуем его в <code>FluentSQLConnectionAsync.cs</code>. Со вторым случаем я не представляю, как можно это реализовать. Хотя нет, догадываюсь, но пока разберём лишь проверенный способ.</p><p>В скопированном файле <code>FluentSQLConnectionAsync.cs</code> также переименуем класс соответствующим образом, а к названиям интерфейсам добавим ключевое слово <code>Async</code>. Проделаем ещё пару вещей по типу того, что добавим ещё одно поле <code>Queue&lt;Func&lt;Task>> _pipeline</code>. Очередь будет содержать лямба-функции (как необычно слышать слово «функция» в C#, бррр, аж мурашки по коже), так как мы не хотим создавать шаманить, а хотим красивый, лаконичный код. В общем, вот весь код для асинхронной реализации:</p><pre><code class=\"cs\">using Microsoft.Data.SqlClient;\n\nnamespace FluentAPI;\n\npublic record FluentSQLConnectionAsyncBuilder&lt;TData>\n{\n    public string ConnectionString { get; set; }\n    public List&lt;TData> Data { get; set; }\n}\n\npublic interface IFluentSQLAsyncQuery&lt;TData>\n{\n    IFluentSQLAsyncSelection&lt;TData> Query(string sql);\n}\n\npublic interface IFluentSQLAsyncQueryResult&lt;TData>\n{\n    Task&lt;List&lt;TData>> ToListAsync();\n}\n\npublic interface IFluentSQLAsyncSelection&lt;TData> : IFluentSQLAsyncQueryResult&lt;TData>\n{\n    IFluentSQLAsyncSelection&lt;TData> Where(Func&lt;TData, bool> predicate);\n\n}\n\npublic sealed class FluentSQLConnectionAsync&lt;TData>\n    : IFluentSQLAsyncQuery&lt;TData>, IFluentSQLAsyncQueryResult&lt;TData>, IFluentSQLAsyncSelection&lt;TData>\n{\n    IEnumerable&lt;TData> _data;\n    IEnumerable&lt;TData> _queredData;\n    SqlConnection _connection;\n    Queue&lt;Func&lt;Task>> _pipeline;\n\n    FluentSQLConnectionAsync(string connectionString, IEnumerable&lt;TData> data)\n    {\n        _queredData = new List&lt;TData>();\n        _pipeline = new();\n        _connection = new(connectionString);\n        _data = data;\n    }\n\n    public static IFluentSQLAsyncQuery&lt;TData> CreateConnection(Action&lt;FluentSQLConnectionAsyncBuilder&lt;TData>> configureConnection)\n    {\n        var builder = new FluentSQLConnectionAsyncBuilder&lt;TData>() { \n            ConnectionString = String.Empty,\n            Data = new List&lt;TData>() \n        };\n        configureConnection(builder);\n        return new FluentSQLConnectionAsync&lt;TData>(builder.ConnectionString, builder.Data);\n    }\n\n    public IFluentSQLAsyncSelection&lt;TData> Query(string sql)\n    {\n        _pipeline.Enqueue(async () => {\n            await Task.Delay(1000);\n            await Task.Run(() => _queredData = _data);\n        });\n\n        return this;\n    }\n\n    public IFluentSQLAsyncSelection&lt;TData> Where(Func&lt;TData, bool> predicate)\n    {\n        _pipeline.Enqueue(async () => await Task.Run(() => _queredData = _queredData.Where(predicate)));\n        return this;\n    }\n\n    public Task&lt;List&lt;TData>> ToListAsync() => Task.Run(async () => {\n            for (var i = 0; i &lt; _pipeline.Count; ++i)\n                await _pipeline.Dequeue().Invoke();\n\n            return _queredData.ToList();\n        });\n}</code></pre><p>Для того, чтобы понять, для чего вообще необходимо асинхронное выполнение кода, запилил некоторые бенчмарки, код которых оставил ниже под спойлером. В таблице и графике ниже видно разницу между асинхронным и синхронным выполнением кода. Но это при том условии, что таски собраны в массив и для их ожидания используется метод <code>Task.WaitAll</code>.</p><div><div class=\"table\"><table><tbody><tr><td colspan=\"2\" data-colwidth=\"109,118\" width=\"109\"><p align=\"center\">Синхронный код</p></td><td colspan=\"2\" data-colwidth=\"108,130\" width=\"108\"><p align=\"center\">Синхронный код с Task.Run</p></td><td colspan=\"2\" data-colwidth=\"111,98\" width=\"111\"><p align=\"center\">Асинхронный код</p></td></tr><tr><td data-colwidth=\"109\" width=\"109\"><p align=\"center\">Кол-во итераций</p></td><td data-colwidth=\"118\" width=\"118\"><p align=\"center\">Время выполнения (ms)</p></td><td data-colwidth=\"108\" width=\"108\"><p align=\"center\">Кол-во итераций</p></td><td data-colwidth=\"130\" width=\"130\"><p align=\"center\">Время выполнения (ms)</p></td><td data-colwidth=\"111\" width=\"111\"><p align=\"center\">Кол-во итераций</p></td><td data-colwidth=\"98\" width=\"98\"><p align=\"center\">Время выполнения (ms)</p></td></tr><tr><td data-colwidth=\"109\" width=\"109\"><p align=\"center\">1</p></td><td data-colwidth=\"118\" width=\"118\"><p align=\"center\">1093</p></td><td data-colwidth=\"108\" width=\"108\"><p align=\"center\">1</p></td><td data-colwidth=\"130\" width=\"130\"><p align=\"center\">1001</p></td><td data-colwidth=\"111\" width=\"111\"><p align=\"center\">1</p></td><td data-colwidth=\"98\" width=\"98\"><p align=\"center\">1010</p></td></tr><tr><td data-colwidth=\"109\" width=\"109\"><p align=\"center\">10</p></td><td data-colwidth=\"118\" width=\"118\"><p align=\"center\">10009</p></td><td data-colwidth=\"108\" width=\"108\"><p align=\"center\">10</p></td><td data-colwidth=\"130\" width=\"130\"><p align=\"center\">1024</p></td><td data-colwidth=\"111\" width=\"111\"><p align=\"center\">10</p></td><td data-colwidth=\"98\" width=\"98\"><p align=\"center\">1005</p></td></tr><tr><td data-colwidth=\"109\" width=\"109\"><p align=\"center\">50</p></td><td data-colwidth=\"118\" width=\"118\"><p align=\"center\">50050</p></td><td data-colwidth=\"108\" width=\"108\"><p align=\"center\">50</p></td><td data-colwidth=\"130\" width=\"130\"><p align=\"center\">2704</p></td><td data-colwidth=\"111\" width=\"111\"><p align=\"center\">50</p></td><td data-colwidth=\"98\" width=\"98\"><p align=\"center\">1003</p></td></tr><tr><td data-colwidth=\"109\" width=\"109\"><p align=\"center\">100</p></td><td data-colwidth=\"118\" width=\"118\"><p align=\"center\">100099</p></td><td data-colwidth=\"108\" width=\"108\"><p align=\"center\">100</p></td><td data-colwidth=\"130\" width=\"130\"><p align=\"center\">5247</p></td><td data-colwidth=\"111\" width=\"111\"><p align=\"center\">100</p></td><td data-colwidth=\"98\" width=\"98\"><p align=\"center\">1015</p></td></tr></tbody></table></div></div><figure class=\"full-width \"><img src=\"https://habrastorage.org/getpro/habr/upload_files/d6c/ff2/a72/d6cff2a72928513293723b8cc215173a.svg\" alt=\"График сравнения производительности синхронного и асинхронного кода\" title=\"График сравнения производительности синхронного и асинхронного кода\" width=\"1100\" height=\"400\"/><figcaption>График сравнения производительности синхронного и асинхронного кода</figcaption></figure><p>Как видно из выше перечисленной статистики, в идеальных условиях и при большом количестве операций асинхронный код невероятно эффективно выполняет свою задачу.</p><details class=\"spoiler\"><summary>Код бенчмарков</summary><div class=\"spoiler__content\"><p>Сразу скажу, что не стал париться на счёт того, чтобы завести бенчмарки под BenchmarkDotNet, так как библиотека без костылей не хочет работать со всем, что относится к многопоточности и асинхронности. Хотя я видел какой-то форк, который позволяет из коробки запускать бенчмарки с многопоточностью и асинхронностью. Но зачем нам он, когда есть старый-добрый Stopwatch?</p><pre><code class=\"cs\">using System.Diagnostics;\n\nnamespace FluentAPI;\n\npublic class Program {\n    public static void Main(string[] args) {\n        foreach (var count in new int[] { 1, 10, 50, 100 })\n        {\n            Console.WriteLine($\"Count ops: {count} {{\");\n\n            var nonAsyncStopwatch = Stopwatch.StartNew();\n\n            Enumerable.Range(0, count)\n                .Select(_ => FluentSQLQuery())\n                .ToArray();\n            \n            Console.WriteLine($\"\\tNon-async: {nonAsyncStopwatch.ElapsedMilliseconds}ms\");\n\n            var syncInAsyncStopwatch = Stopwatch.StartNew();\n\n            var tasks = Enumerable.Range(0, count)\n                .Select(_ => Task.Run(() => FluentSQLQuery()))\n                .ToArray();\n            Task.WaitAll(tasks);\n\n            Console.WriteLine($\"\\tSync in async: {syncInAsyncStopwatch.ElapsedMilliseconds}ms\");\n\n            var asyncStopwatch = Stopwatch.StartNew();\n\n            var asyncTasks = Enumerable.Range(0, count)\n                .Select(_ => FluentSQLQueryAsync())\n                .ToArray();\n            Task.WaitAll(asyncTasks);\n\n            Console.WriteLine($\"\\tAsync: {asyncStopwatch.ElapsedMilliseconds}ms\\n}}\");\n        }\n    }\n    static List&lt;int> FluentSQLQuery() => FluentSQLConnection&lt;int>\n        .CreateConnection(builder => {\n            builder.ConnectionString = \"Data Source=.;Initial Catalog=FluentAPI;Integrated Security=True\";\n            builder.Data = Enumerable.Range(0, 10_000).ToList();\n        })\n        .Query(\"SELECT * FROM Numbers\")\n        .Where(n => n % 5 == 0)\n        .ToList();\n\n    static async Task&lt;List&lt;int>> FluentSQLQueryAsync() => await FluentSQLConnectionAsync&lt;int>\n        .CreateConnection(builder => {\n            builder.ConnectionString = \"Data Source=.;Initial Catalog=FluentAPI;Integrated Security=True\";\n            builder.Data = Enumerable.Range(0, 10_000).ToList();\n        })\n        .Query(\"SELECT * FROM Numbers\")\n        .Where(n => n % 5 == 0)\n        .ToListAsync();\n}</code></pre><p></p></div></details><a class=\"anchor\" name=\"Optional_pattern\" id=\"Optional_pattern\"></a><h3>Optional pattern</h3><p>Optional pattern — паттерн, согласно которому результат функций упаковывается в структуру Some&lt;T>; в случае ошибки используется вариант Some&lt;T, Error>, а при отсутствии значения вовсе используется структура None&lt;T>. </p><p>Данный паттерн позволяет заменить try\\catch или, в нашем случае, писать без остановок на проверки код в Fluent-стиле. Нет, проверки, конечно, будут, но они будут лаконично встроены где-то посередине вызовов других методов.</p><p>Библиотека <a href=\"https://github.com/nlkl/Optional\" rel=\"noopener noreferrer nofollow\">Optional </a>позволяет в C# реализовать Optional pattern. В таких языках, как Rust и Swift, данный паттерн используется по-умолчанию. На счёт Swift не уверен, но в Rust из-за этого просто-напросто отсутствуют стейтменты try\\catch.</p><p>Ниже представлен простой пример использования Optional pattern с Fluent API:</p><pre><code class=\"cs\">using Microsoft.Data.SqlClient;\nusing Optional;\n\nnamespace FluentAPI.Optional;\n\npublic record FluentSQLConnectionBuilder&lt;TData>\n{\n    public string ConnectionString { get; set; }\n    public List&lt;TData> Data { get; set; }\n}\n\npublic sealed class FluentSQLConnection&lt;TData>\n{\n    IEnumerable&lt;TData> _data;\n    SqlConnection _connection;\n\n    FluentSQLConnection(string connectionString, IEnumerable&lt;TData> data)\n    {\n        _connection = new SqlConnection(connectionString);\n        _data = data;\n    }\n\n    public static FluentSQLConnection&lt;TData> CreateConnection(Action&lt;FluentSQLConnectionBuilder&lt;TData>> configureConnection = null!)\n    {\n        var builder = new FluentSQLConnectionBuilder&lt;TData>() { \n            ConnectionString = String.Empty,\n            Data = new List&lt;TData>() \n        };\n        configureConnection?.Invoke(builder);\n        return new FluentSQLConnection&lt;TData>(builder.ConnectionString, builder.Data);\n    }\n\n    public Option&lt;IEnumerable&lt;TData>,QueryError> Query(string sql)\n    {\n        Task.Delay(1000).Wait();\n\n        return Option.Some&lt;IEnumerable&lt;TData>,QueryError>(_data);\n    }\n\n    public Option&lt;IEnumerable&lt;TData>,QueryError> QueryWithoutResult(string sql)\n    {\n        Task.Delay(1000).Wait();\n\n        return Option.None&lt;IEnumerable&lt;TData>,QueryError>(new QueryError());\n    }\n\n    public record struct QueryError(string Message = \"Query Error\");\n}</code></pre><pre><code class=\"cs\">using Optional.Unsafe;\n\nnamespace FluentAPI;\n\npublic class Program {\n    public static void Main(string[] args) {\n        var data = FluentAPI.Optional.FluentSQLConnection&lt;int>\n            .CreateConnection()\n            .Query(\"SELECT * FROM Table\")\n            .ValueOr(new int[] { 1, 2, 3, 4, 5 })\n            .Where(n => n % 5 == 0)\n            .ToList();\n\n        PrintList(data);\n\n        var data1 = FluentAPI.Optional.FluentSQLConnection&lt;int>\n            .CreateConnection()\n            .QueryWithoutResult(\"SELECT * FROM Table\")\n            .ValueOrFailure()\n            .Where(n => n % 2 == 0)\n            .ToList();\n\n        PrintList(data1);\n    }\n    static void PrintList&lt;T>(IEnumerable&lt;T> data)\n    {\n        Console.WriteLine(\"Data: [\");\n        foreach (var item in data)\n        {\n            Console.WriteLine($\"\\t{item}\");\n        }\n        Console.WriteLine(\"]\");\n    }\n}</code></pre><p>Обратите внимание на методы <code>ValueOr</code> и <code>ValueOrFailure</code>, расположенные на 10 и 19 строках второго листинга. Первый метод, если обнаруживает, что получен <code>None</code>, то возвращает объект, который был ему передан в качестве аргумента, иначе возвращает объект из <code>Option</code>. Второй же метод позволяет выкинуть исключение, если получил <code>None</code>. </p><p>Минус второго метода в том, что нельзя настроить под себя исключения, поэтому не получится с помощью этого метода получать какую-либо информацию об ошибках. Однако это можно исправить, используя метод <code>Match</code>. С помощью данного метода можно определить действия при том или ином результате. Вот немного переписанный пример:</p><pre><code class=\"cs\">var data1 = FluentAPI.Optional.FluentSQLConnection&lt;int>\n            .CreateConnection()\n            .QueryWithoutResult(\"SELECT * FROM Table\")\n            .Match(\n                some: d => d,\n                none: e => throw new Exception(e.Message)\n            )\n            .Where(n => n % 2 == 0)\n            .ToList();\n\n  PrintList(data1);</code></pre><p>Как видно из кода, метод <code>Match</code> получает в качестве аргументов делегаты. Делегат <code>some</code> вызывается в том случае, если <code>Option</code> является <code>Some</code>, и ему передаётся в качестве аргумента упакованный в вышеупомянутую структуру объект. Над ним можно произвести какие-то действия, но, чаще всего, его просто возвращают. Второй делегат вызывается в случае отсутствия значения, обозначенное структурой <code>None</code>. Там можно вернуть какое-то значение или выкинуть собственное исключение, как это и сделано в примере выше.</p><p>Также можно сказать про метод <code>ValueOrDefault</code>, однако он находится в неймспейсе <code>Optional.Unsafe</code>, название которого говорит само за себя. Использовать этот или другие методы из данного пространства имён не желательно. Лучше ограничится теми, что находятся в основном пространстве имён библиотеки.</p><a class=\"anchor\" name=\"%D0%98%D1%82%D0%BE%D0%B3%D0%BE\" id=\"Итого\"></a><h2>Итого</h2><p>Из всего вышенаписанного можно сделать выводы, что Fluent API достаточно полезная дизайн-система интерфейсов, которая позволяет с лёгкостью руководить последовательность инициализации свойств конечного автомата и работы методов, а также как добавить поддержку асинхронного выполнения кода. Также с помощью вышеобозначенного Optional pattern реализовать простую обработку исключений и ошибок, позволяя обрабатывать их, не выходя из контекста Fluent API.</p><p>Стоит также сказать, что данный API-дизайн не универсальный, и нужно подумать перед тем, как его сувать везде, куда только можно. Ведь другой подход может быть наиболее эффективным или более легко реализуемым.</p><p></p></div>",
    "tags": [
        {
            "titleHtml": "csharp"
        },
        {
            "titleHtml": "fluent api"
        },
        {
            "titleHtml": "fluent interfaces"
        },
        {
            "titleHtml": "fluent validation"
        },
        {
            "titleHtml": "api design"
        },
        {
            "titleHtml": "asynchronous"
        }
    ],
    "metadata": {
        "stylesUrls": [],
        "scriptUrls": [],
        "shareImageUrl": "https://habrastorage.org/getpro/habr/upload_files/ff3/a13/d50/ff3a13d504fcb09947e7a0b9508a7227.jpg",
        "shareImageWidth": 1200,
        "shareImageHeight": 630,
        "vkShareImageUrl": "https://habrastorage.org/getpro/habr/upload_files/ff3/a13/d50/ff3a13d504fcb09947e7a0b9508a7227.jpg",
        "schemaJsonLd": "{\"@context\":\"http:\\/\\/schema.org\",\"@type\":\"Article\",\"mainEntityOfPage\":{\"@type\":\"WebPage\",\"@id\":\"https:\\/\\/habr.com\\/ru\\/post\\/695966\\/\"},\"headline\":\"Создаём асинхронный Fluent API\",\"datePublished\":\"2022-10-28T16:17:45+03:00\",\"dateModified\":\"2022-10-28T17:56:32+03:00\",\"author\":{\"@type\":\"Person\",\"name\":\"Ertanic\"},\"publisher\":{\"@type\":\"Organization\",\"name\":\"Habr\",\"logo\":{\"@type\":\"ImageObject\",\"url\":\"https:\\/\\/habrastorage.org\\/webt\\/a_\\/lk\\/9m\\/a_lk9mjkccjox-zccjrpfolmkmq.png\"}},\"description\":\"Недавно я захотел сделать более удобный способ взаимодействия с кое-каким классом в одном из модулей приложения. Тогда-то я вспомнил про Fluent API, который в мо...\",\"url\":\"https:\\/\\/habr.com\\/ru\\/post\\/695966\\/#post-content-body\",\"about\":[\"h_api\",\"h_csharp\",\"h_oop\",\"h_parallel_programming\",\"f_develop\"],\"image\":[\"https:\\/\\/habr.com\\/share\\/publication\\/695966\\/0ac24bfa3d070ccd229b06922cf52c60\\/\",\"https:\\/\\/habrastorage.org\\/getpro\\/habr\\/upload_files\\/9fb\\/71a\\/3d5\\/9fb71a3d5c731967607287f642ab89ca.jpg\",\"https:\\/\\/habrastorage.org\\/getpro\\/habr\\/upload_files\\/90c\\/be7\\/1c3\\/90cbe71c348cb97a57ea383c96f0e2aa.png\",\"https:\\/\\/habrastorage.org\\/getpro\\/habr\\/upload_files\\/d6c\\/ff2\\/a72\\/d6cff2a72928513293723b8cc215173a.svg\"]}",
        "metaDescription": "Недавно я захотел сделать более удобный способ взаимодействия с кое-каким классом в одном из модулей приложения. Тогда-то я вспомнил про Fluent API, который в моём случае очень хорошо подходил. Я...",
        "mainImageUrl": null,
        "amp": true,
        "customTrackerLinks": []
    },
    "polls": [],
    "commentsEnabled": true,
    "rulesRemindEnabled": false,
    "votesEnabled": true,
    "status": "published",
    "plannedPublishTime": null,
    "checked": null,
    "hasPinnedComments": false,
    "isEditorial": false
}